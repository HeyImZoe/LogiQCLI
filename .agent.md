# LogiQ CLI - AI-Powered Code Assistant

## Project Overview

- **Language**: C# (.NET 9.0)
- **Type**: Console Application / CLI Tool
- **Purpose**: AI-powered code assistant that provides interactive chat interface with tool execution capabilities
- **Package Name**: LogiQCLI
- **Tool Command**: `logiq`
- **Main Dependencies**: Spectre.Console, Octokit

## Key Features

- Interactive chat interface with AI models via OpenRouter API
- Extensible tool system with automatic discovery and registration
- Multiple operation modes with tool restrictions
- GitHub integration capabilities
- Built-in testing framework
- Configuration management with interactive setup

## Project Structure

### Core Directories

- **`LogiQCLI/`** - Main project directory
  - **`Core/`** - Core business logic and models
    - `Models/Configuration/` - Application settings and configuration
    - `Models/Modes/` - Mode management interfaces and implementations
    - `Services/` - Core services (configuration, mode management)
  - **`Tools/`** - Tool system implementation
    - `Core/` - Tool framework (registry, factory, handler, interfaces)
    - `FileOperations/` - File manipulation tools
    - `SystemOperations/` - System command execution tools
    - `ContentManipulation/` - Content processing tools
    - `GitHub/` - GitHub integration tools
  - **`Infrastructure/`** - External service integrations
    - `ApiClients/OpenRouter/` - OpenRouter API client
    - `ApiClients/GitHub/` - GitHub API client wrapper
  - **`Presentation/`** - UI layer
    - `Console/` - Console interface implementation
    - `Console/Components/` - UI components (rendering, input handling)
    - `Console/Animation/` - Animation and visual effects
    - `Console/Session/` - Chat session management
  - **`Tests/`** - Testing framework and test implementations

### Key Files

- **`Program.cs`** - Application entry point and service initialization
- **`LogiQCLI.csproj`** - Project configuration with CLI tool packaging
- **`LogiQCLI.sln`** - Visual Studio solution file

## Architecture Patterns

### Dependency Injection
- Custom service container implementation (`ServiceContainer`)
- Factory pattern for tool creation (`ToolFactory`)
- Service registration with lifetime management

### Tool System
- Automatic tool discovery via reflection
- Attribute-based tool metadata (`ToolMetadataAttribute`)
- Lazy loading with proxy pattern (`LazyToolProxy`)
- Tool registry for centralized management
- Mode-based tool filtering and access control

### Configuration Management
- JSON-based settings persistence
- Interactive configuration setup
- API key management with multiple providers
- Workspace and model configuration

## Development Guidelines

### Code Organization
- Follow namespace conventions matching directory structure
- Separate concerns: Core logic, Infrastructure, Presentation
- Use interfaces for abstractions (`IToolRegistry`, `IModeManager`, etc.)
- Implement proper error handling with user-friendly messages

### Tool Development
- Inherit from appropriate base classes or implement `ITool` interface
- Use `ToolMetadataAttribute` for tool discovery
- Implement proper parameter validation
- Follow async/await patterns for I/O operations
- Include appropriate error handling and user feedback

### Testing
- Use built-in test framework (`TestRunner`)
- Support category-based test filtering
- Include both unit and integration tests
- Test tool execution and error scenarios

### UI/UX Standards
- Use Spectre.Console for rich console output
- Implement consistent message styling (`MessageRenderer`)
- Provide clear error messages and user guidance
- Support interactive input with proper validation
- Use animations and progress indicators for long operations

## Configuration

### API Keys
- Support multiple API key providers
- Configurable active API key selection
- Secure storage in user data directory

### Models
- Default models configured in `ApplicationSettings`
- Support for various AI providers (OpenAI, Anthropic, Google, etc.)
- Model selection per conversation

### Modes
- Configurable operation modes with tool restrictions
- Mode-specific behavior and capabilities
- Dynamic mode switching during runtime

## Build and Deployment

### CLI Tool Packaging
- Configured as .NET Global Tool (`PackAsTool=true`)
- Command name: `logiq`
- Automatic NuGet package generation
- Version management in project file

### Development Setup
- Requires .NET 9.0 SDK
- Visual Studio 2022 recommended
- Git for version control

## Best Practices

### Error Handling
- Always provide meaningful error messages to users
- Use try-catch blocks around external API calls
- Validate user input before processing
- Log errors appropriately for debugging

### Performance
- Use async/await for I/O operations
- Implement lazy loading where appropriate
- Cache frequently accessed data
- Optimize tool discovery and registration

### Security
- Secure API key storage and handling
- Validate tool parameters to prevent injection
- Sanitize user input before execution
- Implement proper access controls for tools

### Extensibility
- Design tools as plugins with clear interfaces
- Use dependency injection for loose coupling
- Support dynamic tool loading and registration
- Maintain backward compatibility in tool interfaces

## Testing

### Test Execution
- Run all tests: `logiq --test`
- Run specific category: `logiq --test --category <category>`
- Run specific test: `logiq --test --test-name <name>`

### Test Categories
- Unit tests for individual components
- Integration tests for tool execution
- API client tests for external services
- Configuration tests for settings management

## Common Commands

### Interactive Mode
- Start chat interface: `logiq`
- Settings management: `/settings`
- Mode switching: `/mode <mode-name>`
- Help: `/help`

### Configuration
- Initial setup runs automatically on first launch
- Workspace configuration required
- API key setup for AI model access
- GitHub token optional for repository operations